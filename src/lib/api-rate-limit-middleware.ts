import { NextRequest, NextResponse } from 'next/server';\nimport { aiRateLimiter } from './ai-rate-limiter';\n\ninterface RateLimitConfig {\n  windowMs?: number;\n  maxRequests?: number;\n  skipSuccessfulRequests?: boolean;\n  skipFailedRequests?: boolean;\n  standardHeaders?: boolean;\n  legacyHeaders?: boolean;\n}\n\ninterface RateLimitResponse {\n  success: boolean;\n  limit: number;\n  remaining: number;\n  reset: number;\n  retryAfter?: number;\n}\n\n/**\n * Enhanced Rate Limiting Middleware for API Security\n * Protects against DDoS attacks and abuse\n */\nexport class ApiRateLimitMiddleware {\n  private config: Required<RateLimitConfig>;\n\n  constructor(config: RateLimitConfig = {}) {\n    this.config = {\n      windowMs: config.windowMs || 60 * 1000, // 1 minute default\n      maxRequests: config.maxRequests || 100, // 100 requests per minute\n      skipSuccessfulRequests: config.skipSuccessfulRequests || false,\n      skipFailedRequests: config.skipFailedRequests || false,\n      standardHeaders: config.standardHeaders || true,\n      legacyHeaders: config.legacyHeaders || false,\n    };\n  }\n\n  /**\n   * Extract client identifier from request\n   */\n  private getClientId(request: NextRequest): string {\n    // Try to get client IP from various headers\n    const forwarded = request.headers.get('x-forwarded-for');\n    const realIp = request.headers.get('x-real-ip');\n    const cfConnectingIp = request.headers.get('cf-connecting-ip');\n    \n    // Use the most reliable IP source\n    const ip = cfConnectingIp || realIp || forwarded || 'unknown';\n    \n    // If forwarded contains multiple IPs, take the first one\n    return ip.split(',')[0].trim();\n  }\n\n  /**\n   * Generate rate limit headers\n   */\n  private generateHeaders(limit: number, remaining: number, reset: number): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (this.config.standardHeaders) {\n      headers['X-RateLimit-Limit'] = limit.toString();\n      headers['X-RateLimit-Remaining'] = remaining.toString();\n      headers['X-RateLimit-Reset'] = reset.toString();\n    }\n    \n    if (this.config.legacyHeaders) {\n      headers['X-Rate-Limit-Limit'] = limit.toString();\n      headers['X-Rate-Limit-Remaining'] = remaining.toString();\n      headers['X-Rate-Limit-Reset'] = reset.toString();\n    }\n    \n    return headers;\n  }\n\n  /**\n   * Check if request is allowed\n   */\n  public async checkRateLimit(request: NextRequest): Promise<RateLimitResponse> {\n    const clientId = this.getClientId(request);\n    \n    // Check if request is allowed\n    const isAllowed = aiRateLimiter.isAllowed(clientId);\n    const remaining = aiRateLimiter.getRemainingRequests(clientId);\n    \n    const response: RateLimitResponse = {\n      success: isAllowed,\n      limit: this.config.maxRequests,\n      remaining,\n      reset: Date.now() + this.config.windowMs,\n    };\n    \n    if (!isAllowed) {\n      response.retryAfter = Math.ceil(this.config.windowMs / 1000);\n    }\n    \n    return response;\n  }\n\n  /**\n   * Create rate limited response\n   */\n  public createRateLimitedResponse(rateLimitInfo: RateLimitResponse): NextResponse {\n    const headers = this.generateHeaders(\n      rateLimitInfo.limit,\n      rateLimitInfo.remaining,\n      rateLimitInfo.reset\n    );\n    \n    return new NextResponse(\n      JSON.stringify({\n        error: 'Too Many Requests',\n        message: 'Rate limit exceeded. Please try again later.',\n        retryAfter: rateLimitInfo.retryAfter,\n      }),\n      {\n        status: 429,\n        headers: {\n          'Content-Type': 'application/json',\n          ...headers,\n          'Retry-After': rateLimitInfo.retryAfter?.toString() || '60',\n        },\n      }\n    );\n  }\n\n  /**\n   * Middleware function for Next.js API routes\n   */\n  public middleware() {\n    return async (request: NextRequest): Promise<NextResponse | null> => {\n      try {\n        const rateLimitInfo = await this.checkRateLimit(request);\n        \n        if (!rateLimitInfo.success) {\n          return this.createRateLimitedResponse(rateLimitInfo);\n        }\n        \n        // Add rate limit headers to successful responses\n        const headers = this.generateHeaders(\n          rateLimitInfo.limit,\n          rateLimitInfo.remaining,\n          rateLimitInfo.reset\n        );\n        \n        // Return null to continue processing\n        // The calling function should add these headers to the response\n        return null;\n      } catch (error) {\n        console.error('Rate limiting error:', error);\n        // In case of error, allow the request to proceed\n        return null;\n      }\n    };\n  }\n}\n\n// Pre-configured rate limiters for different use cases\nexport const strictRateLimit = new ApiRateLimitMiddleware({\n  windowMs: 60 * 1000, // 1 minute\n  maxRequests: 10, // Strict limit for sensitive operations\n});\n\nexport const standardRateLimit = new ApiRateLimitMiddleware({\n  windowMs: 60 * 1000, // 1 minute\n  maxRequests: 100, // Standard limit for regular operations\n});\n\nexport const relaxedRateLimit = new ApiRateLimitMiddleware({\n  windowMs: 60 * 1000, // 1 minute\n  maxRequests: 1000, // Relaxed limit for less sensitive operations\n});\n\n/**\n * Higher-order function to apply rate limiting to API handlers\n */\nexport function withRateLimit(\n  handler: (request: NextRequest) => Promise<NextResponse>,\n  rateLimiter: ApiRateLimitMiddleware = standardRateLimit\n) {\n  return async (request: NextRequest): Promise<NextResponse> => {\n    const rateLimitResponse = await rateLimiter.middleware()(request);\n    \n    if (rateLimitResponse) {\n      return rateLimitResponse;\n    }\n    \n    const response = await handler(request);\n    \n    // Add rate limit headers to the response\n    const rateLimitInfo = await rateLimiter.checkRateLimit(request);\n    const headers = rateLimiter.generateHeaders(\n      rateLimitInfo.limit,\n      rateLimitInfo.remaining,\n      rateLimitInfo.reset\n    );\n    \n    // Clone the response to add headers\n    const responseClone = new NextResponse(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: {\n        ...Object.fromEntries(response.headers.entries()),\n        ...headers,\n      },\n    });\n    \n    return responseClone;\n  };\n}