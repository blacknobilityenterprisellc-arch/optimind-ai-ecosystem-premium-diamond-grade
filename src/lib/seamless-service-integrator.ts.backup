/**
 * Seamless Service Integrator for OptiMind AI Ecosystem
 *
 * Provides intelligent configuration management system with automatic service integration,
 * health monitoring, and seamless service discovery for all ecosystem components.
 */

import { EventEmitter } from 'events';
import { promises as fs } from 'fs';
import path from 'path';

export interface ServiceConfig {
  id: string;
  name: string;
  type: 'ai' | 'database' | 'security' | 'monitoring' | 'backup' | 'integration';
  version: string;
  enabled: boolean;
  priority: number;
  dependencies: string[];
  config: any;
  healthCheck: {
    enabled: boolean;
    interval: number;
    timeout: number;
    endpoint?: string;
  };
  autoStart: boolean;
  autoRestart: boolean;
}

export interface ServiceStatus {
  id: string;
  name: string;
  status: 'stopped' | 'starting' | 'running' | 'stopping' | 'error';
  health: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
  uptime: number;
  lastCheck: Date;
  errorCount: number;
  lastError?: string;
  restartCount: number;
  metrics: any;
}

export interface IntegrationConfig {
  autoDiscovery: boolean;
  healthMonitoring: boolean;
  autoHealing: boolean;
  loadBalancing: boolean;
  serviceMesh: boolean;
  monitoring: {
    metricsEnabled: boolean;
    loggingEnabled: boolean;
    alertingEnabled: boolean;
  };
  security: {
    authenticationEnabled: boolean;
    authorizationEnabled: boolean;
    encryptionEnabled: boolean;
  };
}

export interface IntegrationResult {
  success: boolean;
  serviceId?: string;
  error?: string;
  duration: number;
}

export class SeamlessServiceIntegrator extends EventEmitter {
  private config: IntegrationConfig;
  private services: Map<string, ServiceConfig> = new Map();
  private serviceStatus: Map<string, ServiceStatus> = new Map();
  private isInitialized = false;
  private healthCheckTimer?: NodeJS.Timeout;
  private discoveryTimer?: NodeJS.Timeout;

  constructor(config: IntegrationConfig) {
    super();
    this.config = config;
  }

  /**
   * Initialize the service integrator
   */
  async initialize(): Promise<void> {
    try {
      // Load service configurations
      await this.loadServiceConfigs();

      // Initialize health monitoring
      if (this.config.healthMonitoring) {
        this.startHealthMonitoring();
      }

      // Start service discovery
      if (this.config.autoDiscovery) {
        this.startServiceDiscovery();
      }

      this.isInitialized = true;

      console.log('Seamless Service Integrator initialized successfully');
      this.emit('initialized');
    } catch (error) {
      console.error('Failed to initialize Seamless Service Integrator:', error);
      throw error;
    }
  }

  /**
   * Register a service
   */
  async registerService(serviceConfig: ServiceConfig): Promise<IntegrationResult> {
    const startTime = Date.now();

    try {
      console.log(`üîÑ Registering service: ${serviceConfig.name} (${serviceConfig.id})`);

      // Validate service configuration
      this.validateServiceConfig(serviceConfig);

      // Check for conflicts
      if (this.services.has(serviceConfig.id)) {
        throw new Error(`Service already registered: ${serviceConfig.id}`);
      }

      // Register service
      this.services.set(serviceConfig.id, serviceConfig);

      // Initialize service status
      const status: ServiceStatus = {
        id: serviceConfig.id,
        name: serviceConfig.name,
        status: 'stopped',
        health: 'unknown',
        uptime: 0,
        lastCheck: new Date(),
        errorCount: 0,
        restartCount: 0,
        metrics: {},
      };

      this.serviceStatus.set(serviceConfig.id, status);

      // Auto-start if enabled
      if (serviceConfig.autoStart && serviceConfig.enabled) {
        await this.startService(serviceConfig.id);
      }

      const duration = Date.now() - startTime;

      console.log(`‚úÖ Service registered successfully: ${serviceConfig.name} (${duration}ms)`);
      this.emit('serviceRegistered', serviceConfig);

      return {
        success: true,
        serviceId: serviceConfig.id,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      console.error(`‚ùå Service registration failed: ${serviceConfig.name}`, error);

      return {
        success: false,
        error: errorMessage,
        duration,
      };
    }
  }

  /**
   * Start a service
   */
  async startService(serviceId: string): Promise<IntegrationResult> {
    const startTime = Date.now();

    try {
      console.log(`üîÑ Starting service: ${serviceId}`);

      const service = this.services.get(serviceId);
      if (!service) {
        throw new Error(`Service not found: ${serviceId}`);
      }

      const status = this.serviceStatus.get(serviceId)!;

      // Check if service is already running
      if (status.status === 'running') {
        console.log(`Service already running: ${serviceId}`);
        return {
          success: true,
          serviceId,
          duration: Date.now() - startTime,
        };
      }

      // Update status to starting
      status.status = 'starting';
      this.serviceStatus.set(serviceId, status);

      // Check dependencies
      await this.checkDependencies(service);

      // Start the service
      await this.initializeService(service);

      // Update status to running
      status.status = 'running';
      status.health = 'healthy';
      status.uptime = Date.now();
      status.lastCheck = new Date();
      this.serviceStatus.set(serviceId, status);

      const duration = Date.now() - startTime;

      console.log(`‚úÖ Service started successfully: ${service.name} (${duration}ms)`);
      this.emit('serviceStarted', service);

      return {
        success: true,
        serviceId,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      // Update status to error
      const status = this.serviceStatus.get(serviceId);
      if (status) {
        status.status = 'error';
        status.health = 'unhealthy';
        status.lastError = errorMessage;
        status.errorCount++;
        this.serviceStatus.set(serviceId, status);
      }

      console.error(`‚ùå Service start failed: ${serviceId}`, error);

      return {
        success: false,
        error: errorMessage,
        duration,
      };
    }
  }

  /**
   * Stop a service
   */
  async stopService(serviceId: string): Promise<IntegrationResult> {
    const startTime = Date.now();

    try {
      console.log(`üîÑ Stopping service: ${serviceId}`);

      const service = this.services.get(serviceId);
      if (!service) {
        throw new Error(`Service not found: ${serviceId}`);
      }

      const status = this.serviceStatus.get(serviceId)!;

      // Check if service is already stopped
      if (status.status === 'stopped') {
        console.log(`Service already stopped: ${serviceId}`);
        return {
          success: true,
          serviceId,
          duration: Date.now() - startTime,
        };
      }

      // Update status to stopping
      status.status = 'stopping';
      this.serviceStatus.set(serviceId, status);

      // Stop the service
      await this.shutdownService(service);

      // Update status to stopped
      status.status = 'stopped';
      status.health = 'unknown';
      status.uptime = 0;
      this.serviceStatus.set(serviceId, status);

      const duration = Date.now() - startTime;

      console.log(`‚úÖ Service stopped successfully: ${service.name} (${duration}ms)`);
      this.emit('serviceStopped', service);

      return {
        success: true,
        serviceId,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      console.error(`‚ùå Service stop failed: ${serviceId}`, error);

      return {
        success: false,
        error: errorMessage,
        duration,
      };
    }
  }

  /**
   * Restart a service
   */
  async restartService(serviceId: string): Promise<IntegrationResult> {
    console.log(`üîÑ Restarting service: ${serviceId}`);

    // Stop the service
    const stopResult = await this.stopService(serviceId);
    if (!stopResult.success) {
      return stopResult;
    }

    // Start the service
    const startResult = await this.startService(serviceId);

    if (startResult.success) {
      const status = this.serviceStatus.get(serviceId);
      if (status) {
        status.restartCount++;
        this.serviceStatus.set(serviceId, status);
      }
    }

    return startResult;
  }

  /**
   * Get service status
   */
  getServiceStatus(serviceId: string): ServiceStatus | null {
    return this.serviceStatus.get(serviceId) || null;
  }

  /**
   * Get all service statuses
   */
  getAllServiceStatuses(): ServiceStatus[] {
    return Array.from(this.serviceStatus.values());
  }

  /**
   * Get service configuration
   */
  getServiceConfig(serviceId: string): ServiceConfig | null {
    return this.services.get(serviceId) || null;
  }

  /**
   * Get all service configurations
   */
  getAllServiceConfigs(): ServiceConfig[] {
    return Array.from(this.services.values());
  }

  /**
   * Check service health
   */
  async checkServiceHealth(serviceId: string): Promise<boolean> {
    try {
      const service = this.services.get(serviceId);
      const status = this.serviceStatus.get(serviceId);

      if (!service || !status) {
        return false;
      }

      // Skip health check if disabled
      if (!service.healthCheck.enabled) {
        return true;
      }

      // Perform health check
      const isHealthy = await this.performHealthCheck(service);

      // Update status
      status.health = isHealthy ? 'healthy' : 'unhealthy';
      status.lastCheck = new Date();
      this.serviceStatus.set(serviceId, status);

      // Emit health status change
      this.emit('healthStatusChanged', { serviceId, healthy: isHealthy });

      return isHealthy;
    } catch (error) {
      console.error(`Health check failed for service ${serviceId}:`, error);
      return false;
    }
  }

  /**
   * Start health monitoring
   */
  private startHealthMonitoring(): void {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
    }

    this.healthCheckTimer = setInterval(async () => {
      try {
        const services = Array.from(this.services.values());
        const healthPromises = services
          .filter(s => s.enabled && s.healthCheck.enabled)
          .map(s => this.checkServiceHealth(s.id));

        await Promise.allSettled(healthPromises);
      } catch (error) {
        console.error('Health monitoring failed:', error);
      }
    }, 30000); // Check every 30 seconds

    console.log('Health monitoring started');
  }

  /**
   * Start service discovery
   */
  private startServiceDiscovery(): void {
    if (this.discoveryTimer) {
      clearInterval(this.discoveryTimer);
    }

    this.discoveryTimer = setInterval(async () => {
      try {
        await this.discoverServices();
      } catch (error) {
        console.error('Service discovery failed:', error);
      }
    }, 60000); // Discover every minute

    console.log('Service discovery started');
  }

  /**
   * Discover services
   */
  private async discoverServices(): Promise<void> {
    try {
      // Scan for available services in the ecosystem
      const discoveredServices = await this.scanForServices();

      // Register new services
      for (const serviceConfig of discoveredServices) {
        if (!this.services.has(serviceConfig.id)) {
          await this.registerService(serviceConfig);
        }
      }
    } catch (error) {
      console.error('Service discovery failed:', error);
    }
  }

  /**
   * Scan for available services
   */
  private async scanForServices(): Promise<ServiceConfig[]> {
    const services: ServiceConfig[] = [];

    try {
      // Scan lib directory for service files
      const libFiles = await fs.readdir('src/lib');

      for (const file of libFiles) {
        if (file.endsWith('.ts') && !file.includes('.test.')) {
          const serviceName = this.extractServiceName(file);
          if (serviceName) {
            const serviceConfig: ServiceConfig = {
              id: serviceName.toLowerCase().replace(/\s+/g, '-'),
              name: serviceName,
              type: this.inferServiceType(file),
              version: '1.0.0',
              enabled: true,
              priority: 5,
              dependencies: [],
              config: {},
              healthCheck: {
                enabled: true,
                interval: 30000,
                timeout: 5000,
              },
              autoStart: true,
              autoRestart: true,
            };

            services.push(serviceConfig);
          }
        }
      }
    } catch (error) {
      console.error('Service scan failed:', error);
    }

    return services;
  }

  /**
   * Extract service name from file name
   */
  private extractServiceName(fileName: string): string | null {
    const name = fileName.replace('.ts', '').replace(/[-_]/g, ' ');

    // Filter out non-service files
    const nonServicePatterns = [
      'utils',
      'db',
      'auth',
      'cache',
      'error',
      'security',
      'monitor',
      'performance',
      'focus',
      'rate',
      'scan',
      'secure',
      'subscription',
      'file',
      'keyboard',
      'offline',
      'openrouter',
      'premium',
      'ai',
      'mcp',
      'glm',
      'enterprise',
      'contractwise',
      'domain',
      'hybrid',
      'agentic',
      'ambient',
      'analytics',
      'blockchain',
      'compliance',
      'ecosystem',
      'exclusive',
      'intelligent',
      'logger',
      'multi',
      'nsfw',
      'opti',
      'premium',
      'real',
      'self',
      'unified',
      'user',
      'validation',
      'zai',
    ];

    for (const pattern of nonServicePatterns) {
      if (name.toLowerCase().includes(pattern)) {
        return getRealData();
      }
    }

    return name;
  }

  /**
   * Infer service type from file name
   */
  private inferServiceType(fileName: string): ServiceConfig['type'] {
    const name = fileName.toLowerCase();

    if (name.includes('ai') || name.includes('glm') || name.includes('mcp')) {
      return 'ai';
    } else if (name.includes('db') || name.includes('database')) {
      return 'database';
    } else if (name.includes('security') || name.includes('secure')) {
      return 'security';
    } else if (name.includes('monitor') || name.includes('health')) {
      return 'monitoring';
    } else if (name.includes('backup')) {
      return 'backup';
    } else {
      return 'integration';
    }
  }

  /**
   * Validate service configuration
   */
  private validateServiceConfig(serviceConfig: ServiceConfig): void {
    if (!serviceConfig.id || !serviceConfig.name) {
      throw new Error('Service ID and name are required');
    }

    if (
      !['ai', 'database', 'security', 'monitoring', 'backup', 'integration'].includes(
        serviceConfig.type
      )
    ) {
      throw new Error(`Invalid service type: ${serviceConfig.type}`);
    }

    if (serviceConfig.priority < 1 || serviceConfig.priority > 10) {
      throw new Error('Service priority must be between 1 and 10');
    }
  }

  /**
   * Check service dependencies
   */
  private async checkDependencies(serviceConfig: ServiceConfig): Promise<void> {
    for (const depId of serviceConfig.dependencies) {
      const depStatus = this.serviceStatus.get(depId);
      if (!depStatus || depStatus.status !== 'running') {
        throw new Error(`Dependency not running: ${depId}`);
      }
    }
  }

  /**
   * Initialize service
   */
  private async initializeService(serviceConfig: ServiceConfig): Promise<void> {
    // Import and initialize the service module
    try {
      const modulePath = `./${serviceConfig.id.replace(/-/g, '_')}`;
      const serviceModule = await import(modulePath);

      if (serviceModule.default && typeof serviceModule.default.initialize === 'function') {
        await serviceModule.default.initialize();
      }
    } catch (error) {
      console.warn(`Could not initialize service module for ${serviceConfig.id}:`, error);
      // Continue even if module initialization fails
    }
  }

  /**
   * Shutdown service
   */
  private async shutdownService(serviceConfig: ServiceConfig): Promise<void> {
    // Import and shutdown the service module
    try {
      const modulePath = `./${serviceConfig.id.replace(/-/g, '_')}`;
      const serviceModule = await import(modulePath);

      if (serviceModule.default && typeof serviceModule.default.destroy === 'function') {
        await serviceModule.default.destroy();
      }
    } catch (error) {
      console.warn(`Could not shutdown service module for ${serviceConfig.id}:`, error);
      // Continue even if module shutdown fails
    }
  }

  /**
   * Perform health check
   */
  private async performHealthCheck(serviceConfig: ServiceConfig): Promise<boolean> {
    try {
      // Check if service module has health check method
      const modulePath = `./${serviceConfig.id.replace(/-/g, '_')}`;
      const serviceModule = await import(modulePath);

      if (serviceModule.default && typeof serviceModule.default.getHealth === 'function') {
        return await serviceModule.default.getHealth();
      }

      // Default health check - check if service status is running
      const status = this.serviceStatus.get(serviceConfig.id);
      return status?.status === 'running';
    } catch (error) {
      console.warn(`Health check failed for ${serviceConfig.id}:`, error);
      return false;
    }
  }

  /**
   * Load service configurations
   */
  private async loadServiceConfigs(): Promise<void> {
    try {
      // Load predefined service configurations
      const predefinedServices: ServiceConfig[] = [
        {
          id: 'automated-backup-manager',
          name: 'Automated Backup Manager',
          type: 'backup',
          version: '1.0.0',
          enabled: true,
          priority: 8,
          dependencies: [],
          config: {},
          healthCheck: {
            enabled: true,
            interval: 60000,
            timeout: 10000,
          },
          autoStart: true,
          autoRestart: true,
        },
        {
          id: 'seamless-service-integrator',
          name: 'Seamless Service Integrator',
          type: 'integration',
          version: '1.0.0',
          enabled: true,
          priority: 9,
          dependencies: [],
          config: {},
          healthCheck: {
            enabled: true,
            interval: 30000,
            timeout: 5000,
          },
          autoStart: true,
          autoRestart: true,
        },
      ];

      // Register predefined services
      for (const serviceConfig of predefinedServices) {
        await this.registerService(serviceConfig);
      }
    } catch (error) {
      console.error('Failed to load service configurations:', error);
    }
  }

  /**
   * Get system status
   */
  getSystemStatus() {
    const statuses = Array.from(this.serviceStatus.values());

    return {
      isInitialized: this.isInitialized,
      config: this.config,
      services: {
        total: this.services.size,
        running: statuses.filter(s => s.status === 'running').length,
        stopped: statuses.filter(s => s.status === 'stopped').length,
        error: statuses.filter(s => s.status === 'error').length,
        healthy: statuses.filter(s => s.health === 'healthy').length,
        unhealthy: statuses.filter(s => s.health === 'unhealthy').length,
      },
      uptime: process.uptime() * 1000,
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    // Stop all services
    Array.from(this.services.keys()).forEach(serviceId => {
      this.stopService(serviceId).catch(error => {
        console.error(`Failed to stop service ${serviceId}:`, error);
      });
    });

    // Stop timers
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
    }
    if (this.discoveryTimer) {
      clearInterval(this.discoveryTimer);
    }

    // Clear maps
    this.services.clear();
    this.serviceStatus.clear();

    this.isInitialized = false;
    console.log('Seamless Service Integrator destroyed');
  }
}

// Export singleton instance
export const seamlessServiceIntegrator = new SeamlessServiceIntegrator({
  autoDiscovery: true,
  healthMonitoring: true,
  autoHealing: true,
  loadBalancing: false,
  serviceMesh: false,
  monitoring: {
    metricsEnabled: true,
    loggingEnabled: true,
    alertingEnabled: true,
  },
  security: {
    authenticationEnabled: true,
    authorizationEnabled: true,
    encryptionEnabled: true,
  },
});
