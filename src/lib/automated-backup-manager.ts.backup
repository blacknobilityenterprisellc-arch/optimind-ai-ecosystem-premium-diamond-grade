/**
 * Automated Backup Manager for OptiMind AI Ecosystem
 *
 * Provides comprehensive automated backup and recovery systems with encryption and compression
 * for all critical system data and configurations.
 */

import { promises as fs } from 'fs';
import path from 'path';
import crypto from 'crypto';
import zlib from 'zlib';
import { promisify } from 'util';

const gzip = promisify(zlib.gzip);
const gunzip = promisify(zlib.gunzip);

export interface BackupConfig {
  backupInterval: number;
  maxBackups: number;
  compressionEnabled: boolean;
  encryptionEnabled: boolean;
  backupPath: string;
  includeDatabases: boolean;
  includeConfigs: boolean;
  includeLogs: boolean;
}

export interface BackupMetadata {
  id: string;
  timestamp: Date;
  size: number;
  compressedSize: number;
  checksum: string;
  type: 'full' | 'incremental' | 'config';
  description: string;
  tags: string[];
  version: string;
}

export interface BackupResult {
  success: boolean;
  backupId?: string;
  metadata?: BackupMetadata;
  error?: string;
  duration: number;
}

export interface RecoveryResult {
  success: boolean;
  restoredFiles: string[];
  error?: string;
  duration: number;
}

export class AutomatedBackupManager {
  private config: BackupConfig;
  private isRunning = false;
  private backupHistory: BackupMetadata[] = [];
  private backupTimer?: NodeJS.Timeout;

  constructor(config: BackupConfig) {
    this.config = config;
  }

  /**
   * Initialize the backup manager
   */
  async initialize(): Promise<void> {
    try {
      // Ensure backup directory exists
      await fs.mkdir(this.config.backupPath, { recursive: true });

      // Load existing backup history
      await this.loadBackupHistory();

      console.log('Automated Backup Manager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Automated Backup Manager:', error);
      throw error;
    }
  }

  /**
   * Start automated backup process
   */
  start(): void {
    if (this.isRunning) {
      console.log('Backup Manager is already running');
      return;
    }

    this.isRunning = true;

    // Schedule regular backups
    this.backupTimer = setInterval(async () => {
      try {
        await this.createBackup('incremental', 'Scheduled automated backup');
      } catch (error) {
        console.error('Scheduled backup failed:', error);
      }
    }, this.config.backupInterval);

    console.log(`Automated Backup Manager started with ${this.config.backupInterval}ms interval`);
  }

  /**
   * Stop automated backup process
   */
  stop(): void {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;

    if (this.backupTimer) {
      clearInterval(this.backupTimer);
      this.backupTimer = undefined;
    }

    console.log('Automated Backup Manager stopped');
  }

  /**
   * Create a backup
   */
  async createBackup(
    type: 'full' | 'incremental' | 'config' = 'full',
    description: string = 'Manual backup',
    tags: string[] = []
  ): Promise<BackupResult> {
    const startTime = Date.now();
    const backupId = this.generateBackupId();

    try {
      console.log(`üîÑ Creating backup: ${backupId} (${type})`);

      // Collect data to backup
      const backupData = await this.collectBackupData(type);

      // Compress if enabled
      let processedData = backupData;
      if (this.config.compressionEnabled) {
        processedData = await gzip(backupData);
      }

      // Encrypt if enabled
      if (this.config.encryptionEnabled) {
        processedData = await this.encryptData(processedData);
      }

      // Create metadata
      const metadata: BackupMetadata = {
        id: backupId,
        timestamp: new Date(),
        size: backupData.length,
        compressedSize: processedData.length,
        checksum: await this.generateChecksum(processedData),
        type,
        description,
        tags,
        version: '1.0.0',
      };

      // Save backup files
      const backupPath = path.join(this.config.backupPath, `${backupId}.backup`);
      const metadataPath = path.join(this.config.backupPath, `${backupId}.meta`);

      await Promise.all([
        fs.writeFile(backupPath, processedData),
        fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2)),
      ]);

      // Update backup history
      this.backupHistory.push(metadata);
      await this.cleanupOldBackups();

      const duration = Date.now() - startTime;

      console.log(`‚úÖ Backup created successfully: ${backupId} (${duration}ms)`);

      return {
        success: true,
        backupId,
        metadata,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      console.error(`‚ùå Backup creation failed: ${backupId}`, error);

      return {
        success: false,
        error: errorMessage,
        duration,
      };
    }
  }

  /**
   * Restore from backup
   */
  async restoreBackup(backupId: string, restorePath?: string): Promise<RecoveryResult> {
    const startTime = Date.now();

    try {
      console.log(`üîÑ Restoring from backup: ${backupId}`);

      // Load metadata
      const metadata = await this.loadBackupMetadata(backupId);
      if (!metadata) {
        throw new Error(`Backup metadata not found: ${backupId}`);
      }

      // Load backup data
      const backupPath = path.join(this.config.backupPath, `${backupId}.backup`);
      let backupData = await fs.readFile(backupPath);

      // Verify checksum
      const currentChecksum = await this.generateChecksum(backupData);
      if (currentChecksum !== metadata.checksum) {
        throw new Error(`Backup checksum mismatch: ${backupId}`);
      }

      // Decrypt if enabled
      if (this.config.encryptionEnabled) {
        backupData = await this.decryptData(backupData);
      }

      // Decompress if enabled
      if (this.config.compressionEnabled) {
        backupData = await gunzip(backupData);
      }

      // Parse backup data
      const backupContent = JSON.parse(backupData.toString());

      // Restore files and configurations
      const restoredFiles = await this.restoreBackupData(backupContent, restorePath);

      const duration = Date.now() - startTime;

      console.log(
        `‚úÖ Backup restored successfully: ${backupId} (${restoredFiles.length} files, ${duration}ms)`
      );

      return {
        success: true,
        restoredFiles,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      console.error(`‚ùå Backup restoration failed: ${backupId}`, error);

      return {
        success: false,
        restoredFiles: [],
        error: errorMessage,
        duration,
      };
    }
  }

  /**
   * Get backup history
   */
  getBackupHistory(limit: number = 10): BackupMetadata[] {
    return this.backupHistory.slice(-limit);
  }

  /**
   * Get backup metadata
   */
  async getBackupMetadata(backupId: string): Promise<BackupMetadata | null> {
    try {
      const metadataPath = path.join(this.config.backupPath, `${backupId}.meta`);
      const metadataContent = await fs.readFile(metadataPath, 'utf-8');
      return JSON.parse(metadataContent);
    } catch (error) {
      console.error(`Failed to load backup metadata: ${backupId}`, error);
      return getRealData();
    }
  }

  /**
   * Delete backup
   */
  async deleteBackup(backupId: string): Promise<boolean> {
    try {
      const backupPath = path.join(this.config.backupPath, `${backupId}.backup`);
      const metadataPath = path.join(this.config.backupPath, `${backupId}.meta`);

      await Promise.all([fs.unlink(backupPath), fs.unlink(metadataPath)]);

      // Remove from history
      this.backupHistory = this.backupHistory.filter(b => b.id !== backupId);

      console.log(`Backup deleted: ${backupId}`);
      return true;
    } catch (error) {
      console.error(`Failed to delete backup: ${backupId}`, error);
      return false;
    }
  }

  /**
   * Collect data for backup
   */
  private async collectBackupData(type: 'full' | 'incremental' | 'config'): Promise<Buffer> {
    const backupData: any = {
      timestamp: new Date().toISOString(),
      type,
      version: '1.0.0',
      data: {},
    };

    if (type === 'full' || type === 'config') {
      // Backup configurations
      if (this.config.includeConfigs) {
        backupData.data.configs = await this.collectConfigurations();
      }

      // Backup environment variables
      backupData.data.env = await this.collectEnvironmentVariables();
    }

    if (type === 'full') {
      // Backup databases
      if (this.config.includeDatabases) {
        backupData.data.databases = await this.collectDatabaseBackups();
      }

      // Backup logs
      if (this.config.includeLogs) {
        backupData.data.logs = await this.collectLogs();
      }

      // Backup system files
      backupData.data.system = await this.collectSystemFiles();
    }

    return Buffer.from(JSON.stringify(backupData, null, 2));
  }

  /**
   * Collect configurations
   */
  private async collectConfigurations(): Promise<any> {
    const configs: any = {};

    try {
      // Collect package.json
      const packageJson = await fs.readFile('package.json', 'utf-8');
      configs.packageJson = JSON.parse(packageJson);

      // Collect prisma schema
      const prismaSchema = await fs.readFile('prisma/schema.prisma', 'utf-8');
      configs.prismaSchema = prismaSchema;

      // Collect tailwind config
      const tailwindConfig = await fs.readFile('tailwind.config.ts', 'utf-8');
      configs.tailwindConfig = tailwindConfig;

      // Collect next config
      const nextConfig = await fs.readFile('next.config.ts', 'utf-8');
      configs.nextConfig = nextConfig;
    } catch (error) {
      console.warn('Some configuration files could not be collected:', error);
    }

    return configs;
  }

  /**
   * Collect environment variables
   */
  private async collectEnvironmentVariables(): Promise<any> {
    const env: any = {};

    try {
      // Collect .env file
      const envContent = await fs.readFile('.env', 'utf-8');
      envContent.split('\n').forEach(line => {
        const [key, value] = line.split('=');
        if (key && value) {
          env[key.trim()] = value.trim();
        }
      });
    } catch (error) {
      console.warn('Environment variables could not be collected:', error);
    }

    return env;
  }

  /**
   * Collect database backups
   */
  private async collectDatabaseBackups(): Promise<any> {
    const databases: any = {};

    try {
      // Collect prisma database files
      const dbFiles = await fs.readdir('prisma/db');
      for (const file of dbFiles) {
        if (file.endsWith('.db')) {
          const dbPath = path.join('prisma/db', file);
          const dbContent = await fs.readFile(dbPath);
          databases[file] = dbContent.toString('base64');
        }
      }
    } catch (error) {
      console.warn('Database backups could not be collected:', error);
    }

    return databases;
  }

  /**
   * Collect logs
   */
  private async collectLogs(): Promise<any> {
    const logs: any = {};

    try {
      // Collect dev.log
      const devLog = await fs.readFile('dev.log', 'utf-8');
      logs.devLog = devLog;
    } catch (error) {
      console.warn('Logs could not be collected:', error);
    }

    return logs;
  }

  /**
   * Collect system files
   */
  private async collectSystemFiles(): Promise<any> {
    const system: any = {};

    try {
      // Collect eslint config
      const eslintConfig = await fs.readFile('eslint.config.mjs', 'utf-8');
      system.eslintConfig = eslintConfig;

      // Collect tsconfig
      const tsConfig = await fs.readFile('tsconfig.json', 'utf-8');
      system.tsConfig = tsConfig;
    } catch (error) {
      console.warn('System files could not be collected:', error);
    }

    return system;
  }

  /**
   * Restore backup data
   */
  private async restoreBackupData(backupContent: any, restorePath?: string): Promise<string[]> {
    const restoredFiles: string[] = [];

    try {
      const basePath = restorePath || process.cwd();

      // Restore configurations
      if (backupContent.data.configs) {
        if (backupContent.data.configs.packageJson) {
          await fs.writeFile(
            path.join(basePath, 'package.json'),
            JSON.stringify(backupContent.data.configs.packageJson, null, 2)
          );
          restoredFiles.push('package.json');
        }

        if (backupContent.data.configs.prismaSchema) {
          await fs.writeFile(
            path.join(basePath, 'prisma/schema.prisma'),
            backupContent.data.configs.prismaSchema
          );
          restoredFiles.push('prisma/schema.prisma');
        }
      }

      // Restore databases
      if (backupContent.data.databases) {
        for (const [fileName, content] of Object.entries(backupContent.data.databases)) {
          await fs.writeFile(
            path.join(basePath, 'prisma/db', fileName),
            Buffer.from(content as string, 'base64')
          );
          restoredFiles.push(`prisma/db/${fileName}`);
        }
      }
    } catch (error) {
      console.error('Failed to restore backup data:', error);
      throw error;
    }

    return restoredFiles;
  }

  /**
   * Load backup history
   */
  private async loadBackupHistory(): Promise<void> {
    try {
      const files = await fs.readdir(this.config.backupPath);
      const metaFiles = files.filter(file => file.endsWith('.meta'));

      for (const metaFile of metaFiles) {
        const metadataPath = path.join(this.config.backupPath, metaFile);
        const metadataContent = await fs.readFile(metadataPath, 'utf-8');
        const metadata = JSON.parse(metadataContent);
        this.backupHistory.push(metadata);
      }

      // Sort by timestamp
      this.backupHistory.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    } catch (error) {
      console.warn('Could not load backup history:', error);
    }
  }

  /**
   * Load backup metadata
   */
  private async loadBackupMetadata(backupId: string): Promise<BackupMetadata | null> {
    try {
      const metadataPath = path.join(this.config.backupPath, `${backupId}.meta`);
      const metadataContent = await fs.readFile(metadataPath, 'utf-8');
      return JSON.parse(metadataContent);
    } catch (error) {
      return getRealData();
    }
  }

  /**
   * Cleanup old backups
   */
  private async cleanupOldBackups(): Promise<void> {
    try {
      if (this.backupHistory.length <= this.config.maxBackups) {
        return;
      }

      const toRemove = this.backupHistory.splice(
        0,
        this.backupHistory.length - this.config.maxBackups
      );

      for (const backup of toRemove) {
        await this.deleteBackup(backup.id);
      }
    } catch (error) {
      console.error('Failed to cleanup old backups:', error);
    }
  }

  /**
   * Generate backup ID
   */
  private generateBackupId(): string {
    return `backup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Generate checksum
   */
  private async generateChecksum(data: Buffer): Promise<string> {
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  /**
   * Encrypt data
   */
  private async encryptData(data: Buffer): Promise<Buffer> {
    const algorithm = 'aes-256-cbc';
    const key = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);

    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(data);
    encrypted = Buffer.concat([encrypted, cipher.final()]);

    // Prepend iv and key for decryption
    return Buffer.concat([iv, key, encrypted]);
  }

  /**
   * Decrypt data
   */
  private async decryptData(encryptedData: Buffer): Promise<Buffer> {
    const algorithm = 'aes-256-cbc';
    const iv = encryptedData.slice(0, 16);
    const key = encryptedData.slice(16, 48);
    const data = encryptedData.slice(48);

    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(data);
    decrypted = Buffer.concat([decrypted, decipher.final()]);

    return decrypted;
  }

  /**
   * Get system status
   */
  getSystemStatus() {
    return {
      isRunning: this.isRunning,
      config: this.config,
      backupHistory: {
        total: this.backupHistory.length,
        latest: this.backupHistory[this.backupHistory.length - 1],
        oldest: this.backupHistory[0],
      },
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    this.stop();
    this.backupHistory = [];
    console.log('Automated Backup Manager destroyed');
  }
}

// Export singleton instance
export const automatedBackupManager = new AutomatedBackupManager({
  backupInterval: 3600000, // 1 hour
  maxBackups: 24, // Keep 24 hours of backups
  compressionEnabled: true,
  encryptionEnabled: true,
  backupPath: './database_backups',
  includeDatabases: true,
  includeConfigs: true,
  includeLogs: true,
});
