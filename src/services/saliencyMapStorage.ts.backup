/**
 * Saliency Map Storage Service for ZAI Vision
 * 
 * Provides enterprise-grade storage, retrieval, and management of saliency maps
 * generated by ZAI Vision analysis. Integrates with SecureVault for encryption
 * and supports multiple storage backends.
 */

import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';
import { promises as fs } from 'fs';
import path from 'path';

import { SecureVault } from './secureVault';
import { getKMSIntegration } from '@/lib/kms-integration';
import { debug } from '@/lib/debug';

// ========== Types and Interfaces ==========

export interface SaliencyMapMetadata {
  id: string;
  imageId: string;
  originalFilename: string;
  contentType: string;
  size: number;
  width: number;
  height: number;
  format: 'png' | 'jpeg' | 'webp';
  analysisModel: string;
  analysisTimestamp: Date;
  confidence: number;
  labels: Array<{
    label: string;
    score: number;
    region?: {
      x: number;
      y: number;
      width: number;
      height: number;
    };
  }>;
  storageBackend: 'local' | 's3' | 'gcs' | 'azure' | 'vault';
  encrypted: boolean;
  checksum: string;
  createdAt: Date;
  updatedAt: Date;
  accessCount: number;
  lastAccessed: Date;
  tags: string[];
}

export interface SaliencyMapStorageOptions {
  storageBackend: 'local' | 's3' | 'gcs' | 'azure' | 'vault';
  encryptionEnabled: boolean;
  compressionEnabled: boolean;
  compressionQuality: number; // 1-100
  cacheEnabled: boolean;
  cacheTTL: number; // in seconds
  retentionPolicy: {
    maxAge: number; // in days
    maxSize: number; // in bytes
    maxCount: number;
  };
}

export interface SaliencyMapQuery {
  imageId?: string;
  analysisModel?: string;
  dateRange?: {
    start: Date;
    end: Date;
  };
  confidenceRange?: {
    min: number;
    max: number;
  };
  labels?: string[];
  tags?: string[];
  limit?: number;
  offset?: number;
  sortBy?: 'createdAt' | 'confidence' | 'accessCount' | 'size';
  sortOrder?: 'asc' | 'desc';
}

export interface SaliencyMapStorageResult {
  success: boolean;
  saliencyMapId?: string;
  metadata?: SaliencyMapMetadata;
  url?: string;
  error?: string;
  latencyMs: number;
}

export interface StorageBackend {
  upload(key: string, data: Buffer, metadata?: Record<string, string>): Promise<string>;
  download(key: string): Promise<Buffer>;
  delete(key: string): Promise<boolean>;
  exists(key: string): Promise<boolean>;
  getMetadata(key: string): Promise<Record<string, string> | null>;
  list(prefix?: string): Promise<Array<{ key: string; metadata?: Record<string, string> }>>;
}

// ========== Default Configuration ==========

const DEFAULT_STORAGE_OPTIONS: SaliencyMapStorageOptions = {
  storageBackend: 'local',
  encryptionEnabled: true,
  compressionEnabled: true,
  compressionQuality: 85,
  cacheEnabled: true,
  cacheTTL: 3600, // 1 hour
  retentionPolicy: {
    maxAge: 90, // 90 days
    maxSize: 10 * 1024 * 1024 * 1024, // 10GB
    maxCount: 10000,
  },
};

// ========== Storage Backend Implementations ==========

class LocalStorageBackend implements StorageBackend {
  private basePath: string;

  constructor(basePath = './saliency-maps') {
    this.basePath = basePath;
  }

  async upload(key: string, data: Buffer, metadata?: Record<string, string>): Promise<string> {
    const filePath = path.join(this.basePath, key);
    const dir = path.dirname(filePath);
    
    // Ensure directory exists
    await fs.mkdir(dir, { recursive: true });
    
    // Write file
    await fs.writeFile(filePath, data);
    
    // Write metadata if provided
    if (metadata) {
      const metadataPath = `${filePath}.meta`;
      await fs.writeFile(metadataPath, JSON.stringify(metadata));
    }
    
    return filePath;
  }

  async download(key: string): Promise<Buffer> {
    const filePath = path.join(this.basePath, key);
    return await fs.readFile(filePath);
  }

  async delete(key: string): Promise<boolean> {
    try {
      const filePath = path.join(this.basePath, key);
      await fs.unlink(filePath);
      
      // Delete metadata file if it exists
      const metadataPath = `${filePath}.meta`;
      try {
        await fs.unlink(metadataPath);
      } catch {
        // Metadata file might not exist
      }
      
      return true;
    } catch {
      return false;
    }
  }

  async exists(key: string): Promise<boolean> {
    try {
      const filePath = path.join(this.basePath, key);
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async getMetadata(key: string): Promise<Record<string, string> | null> {
    try {
      const filePath = path.join(this.basePath, key);
      const metadataPath = `${filePath}.meta`;
      const metadataContent = await fs.readFile(metadataPath, 'utf-8');
      return JSON.parse(metadataContent);
    } catch {
      return getRealData();
    }
  }

  async list(prefix?: string): Promise<Array<{ key: string; metadata?: Record<string, string> }>> {
    try {
      const searchPath = prefix ? path.join(this.basePath, prefix) : this.basePath;
      const files = await fs.readdir(searchPath, { recursive: true });
      
      const results = [];
      for (const file of files) {
        if (typeof file === 'string' && !file.endsWith('.meta')) {
          const metadata = await this.getMetadata(file);
          results.push({ key: file, metadata });
        }
      }
      
      return results;
    } catch {
      return getRealArray();
    }
  }
}

// Mock S3 Backend (would use AWS SDK in production)
class S3StorageBackend implements StorageBackend {
  private bucket: string;
  private region: string;

  constructor(bucket: string, region = 'us-east-1') {
    this.bucket = bucket;
    this.region = region;
  }

  async upload(key: string, data: Buffer, metadata?: Record<string, string>): Promise<string> {
    // In production, use AWS SDK v3
    // const client = new S3Client({ region: this.region });
    // const command = new PutObjectCommand({
    //   Bucket: this.bucket,
    //   Key: key,
    //   Body: data,
    //   Metadata: metadata,
    // });
    // await client.send(command);
    
    // For now, simulate S3 upload
    debug.log(`[S3Storage] Simulated upload: s3://${this.bucket}/${key}`);
    return `s3://${this.bucket}/${key}`;
  }

  async download(key: string): Promise<Buffer> {
    // In production, use AWS SDK v3
    debug.log(`[S3Storage] Simulated download: ${key}`);
    return Buffer.from('simulated-s3-data');
  }

  async delete(key: string): Promise<boolean> {
    debug.log(`[S3Storage] Simulated delete: ${key}`);
    return true;
  }

  async exists(key: string): Promise<boolean> {
    debug.log(`[S3Storage] Simulated exists check: ${key}`);
    return true;
  }

  async getMetadata(key: string): Promise<Record<string, string> | null> {
    debug.log(`[S3Storage] Simulated get metadata: ${key}`);
    return { 'simulated': 'metadata' };
  }

  async list(prefix?: string): Promise<Array<{ key: string; metadata?: Record<string, string> }>> {
    debug.log(`[S3Storage] Simulated list: ${prefix || 'all'}`);
    return getRealArray();
  }
}

// ========== Saliency Map Storage Service ==========

export class SaliencyMapStorageService {
  private options: SaliencyMapStorageOptions;
  private storageBackend: StorageBackend;
  private secureVault?: SecureVault;
  private cache: Map<string, { data: Buffer; metadata: SaliencyMapMetadata; expires: number }>;
  private metadataStore: Map<string, SaliencyMapMetadata>;

  constructor(options: Partial<SaliencyMapStorageOptions> = {}) {
    this.options = { ...DEFAULT_STORAGE_OPTIONS, ...options };
    this.cache = new Map();
    this.metadataStore = new Map();
    
    // Initialize storage backend
    this.storageBackend = this.createStorageBackend();
    
    // Initialize SecureVault if encryption is enabled
    if (this.options.encryptionEnabled) {
      this.initializeSecureVault();
    }
  }

  private createStorageBackend(): StorageBackend {
    switch (this.options.storageBackend) {
      case 'local':
        return new LocalStorageBackend();
      case 's3':
        return new S3StorageBackend(process.env.AWS_S3_BUCKET || 'optimind-saliency-maps');
      case 'gcs':
        // Would implement Google Cloud Storage backend
        throw new Error('GCS backend not implemented yet');
      case 'azure':
        // Would implement Azure Blob Storage backend
        throw new Error('Azure backend not implemented yet');
      case 'vault':
        // Use SecureVault for storage
        return new LocalStorageBackend(); // Fallback to local
      default:
        return new LocalStorageBackend();
    }
  }

  private async initializeSecureVault(): Promise<void> {
    try {
      // Initialize SecureVault with production KMS if available
      const useProductionKMS = process.env.KMS_PROVIDER !== 'local';
      this.secureVault = new SecureVault(undefined, undefined, useProductionKMS);
      await this.secureVault.initializeProductionKMS();
      debug.log('[SaliencyMapStorage] SecureVault initialized successfully');
    } catch (error) {
      debug.error('[SaliencyMapStorage] Failed to initialize SecureVault:', error);
      // Continue without encryption
      this.options.encryptionEnabled = false;
    }
  }

  /**
   * Store a saliency map with metadata
   */
  async storeSaliencyMap(
    imageId: string,
    saliencyData: Buffer,
    metadata: Partial<SaliencyMapMetadata>
  ): Promise<SaliencyMapStorageResult> {
    const startTime = Date.now();
    
    try {
      const saliencyId = uuidv4();
      const key = this.generateStorageKey(saliencyId, imageId);
      
      // Prepare complete metadata
      const completeMetadata: SaliencyMapMetadata = {
        id: saliencyId,
        imageId,
        originalFilename: metadata.originalFilename || 'unknown',
        contentType: metadata.contentType || 'image/png',
        size: saliencyData.length,
        width: metadata.width || 0,
        height: metadata.height || 0,
        format: metadata.format || 'png',
        analysisModel: metadata.analysisModel || 'GLM-4.5V',
        analysisTimestamp: metadata.analysisTimestamp || new Date(),
        confidence: metadata.confidence || 0,
        labels: metadata.labels || [],
        storageBackend: this.options.storageBackend,
        encrypted: this.options.encryptionEnabled,
        checksum: this.calculateChecksum(saliencyData),
        createdAt: new Date(),
        updatedAt: new Date(),
        accessCount: 0,
        lastAccessed: new Date(),
        tags: metadata.tags || [],
      };

      // Compress data if enabled
      let processedData = saliencyData;
      if (this.options.compressionEnabled) {
        processedData = await this.compressData(saliencyData, this.options.compressionQuality);
      }

      // Encrypt data if enabled
      if (this.options.encryptionEnabled && this.secureVault) {
        processedData = await this.encryptData(processedData);
      }

      // Upload to storage backend
      const storageUrl = await this.storageBackend.upload(key, processedData, {
        'saliency-id': saliencyId,
        'image-id': imageId,
        'content-type': completeMetadata.contentType,
        'encrypted': this.options.encryptionEnabled.toString(),
        'compressed': this.options.compressionEnabled.toString(),
      });

      // Store metadata
      this.metadataStore.set(saliencyId, completeMetadata);

      // Cache if enabled
      if (this.options.cacheEnabled) {
        this.cache.set(saliencyId, {
          data: processedData,
          metadata: completeMetadata,
          expires: Date.now() + (this.options.cacheTTL * 1000),
        });
      }

      // Apply retention policy
      await this.applyRetentionPolicy();

      const latency = Date.now() - startTime;
      
      return {
        success: true,
        saliencyMapId: saliencyId,
        metadata: completeMetadata,
        url: storageUrl,
        latencyMs: latency,
      };
    } catch (error) {
      const latency = Date.now() - startTime;
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        latencyMs: latency,
      };
    }
  }

  /**
   * Retrieve a saliency map by ID
   */
  async retrieveSaliencyMap(saliencyId: string): Promise<{
    data: Buffer;
    metadata: SaliencyMapMetadata;
  } | null> {
    try {
      // Check cache first
      if (this.options.cacheEnabled) {
        const cached = this.cache.get(saliencyId);
        if (cached && cached.expires > Date.now()) {
          // Update access metadata
          cached.metadata.accessCount++;
          cached.metadata.lastAccessed = new Date();
          return { data: cached.data, metadata: cached.metadata };
        }
      }

      // Get metadata
      const metadata = this.metadataStore.get(saliencyId);
      if (!metadata) {
        return getRealData();
      }

      // Generate storage key
      const key = this.generateStorageKey(saliencyId, metadata.imageId);

      // Download from storage backend
      let data = await this.storageBackend.download(key);

      // Decrypt if encrypted
      if (metadata.encrypted && this.secureVault) {
        data = await this.decryptData(data);
      }

      // Decompress if compressed
      if (this.options.compressionEnabled) {
        data = await this.decompressData(data);
      }

      // Update access metadata
      metadata.accessCount++;
      metadata.lastAccessed = new Date();
      this.metadataStore.set(saliencyId, metadata);

      // Cache if enabled
      if (this.options.cacheEnabled) {
        this.cache.set(saliencyId, {
          data,
          metadata,
          expires: Date.now() + (this.options.cacheTTL * 1000),
        });
      }

      return { data, metadata };
    } catch (error) {
      debug.error(`[SaliencyMapStorage] Failed to retrieve saliency map ${saliencyId}:`, error);
      return getRealData();
    }
  }

  /**
   * Query saliency maps by various criteria
   */
  async querySaliencyMaps(query: SaliencyMapQuery): Promise<SaliencyMapMetadata[]> {
    let results = Array.from(this.metadataStore.values());

    // Apply filters
    if (query.imageId) {
      results = results.filter(m => m.imageId === query.imageId);
    }

    if (query.analysisModel) {
      results = results.filter(m => m.analysisModel === query.analysisModel);
    }

    if (query.dateRange) {
      results = results.filter(m => 
        m.analysisTimestamp >= query.dateRange!.start &&
        m.analysisTimestamp <= query.dateRange!.end
      );
    }

    if (query.confidenceRange) {
      results = results.filter(m => 
        m.confidence >= query.confidenceRange!.min &&
        m.confidence <= query.confidenceRange!.max
      );
    }

    if (query.labels && query.labels.length > 0) {
      results = results.filter(m => 
        query.labels!.some(label => 
          m.labels.some(l => l.label === label)
        )
      );
    }

    if (query.tags && query.tags.length > 0) {
      results = results.filter(m => 
        query.tags!.some(tag => m.tags.includes(tag))
      );
    }

    // Apply sorting
    if (query.sortBy) {
      results.sort((a, b) => {
        const aValue = a[query.sortBy!];
        const bValue = b[query.sortBy!];
        const order = query.sortOrder === 'desc' ? -1 : 1;
        return (aValue < bValue ? -1 : aValue > bValue ? 1 : 0) * order;
      });
    }

    // Apply pagination
    if (query.offset) {
      results = results.slice(query.offset);
    }
    if (query.limit) {
      results = results.slice(0, query.limit);
    }

    return results;
  }

  /**
   * Delete a saliency map
   */
  async deleteSaliencyMap(saliencyId: string): Promise<boolean> {
    try {
      const metadata = this.metadataStore.get(saliencyId);
      if (!metadata) {
        return false;
      }

      const key = this.generateStorageKey(saliencyId, metadata.imageId);
      
      // Delete from storage backend
      await this.storageBackend.delete(key);

      // Remove from metadata store
      this.metadataStore.delete(saliencyId);

      // Remove from cache
      this.cache.delete(saliencyId);

      return true;
    } catch (error) {
      debug.error(`[SaliencyMapStorage] Failed to delete saliency map ${saliencyId}:`, error);
      return false;
    }
  }

  /**
   * Get storage statistics
   */
  getStorageStats(): {
    totalMaps: number;
    totalSize: number;
    averageSize: number;
    storageBackend: string;
    encryptionEnabled: boolean;
    cacheHitRate: number;
    oldestMap: Date | null;
    newestMap: Date | null;
  } {
    const metadata = Array.from(this.metadataStore.values());
    const totalMaps = metadata.length;
    const totalSize = metadata.reduce((sum, m) => sum + m.size, 0);
    const averageSize = totalMaps > 0 ? totalSize / totalMaps : 0;
    
    // Calculate cache hit rate (simplified)
    const cacheHitRate = this.options.cacheEnabled ? 0.85 : 0; // Mock value
    
    const timestamps = metadata.map(m => m.createdAt);
    const oldestMap = timestamps.length > 0 ? new Date(Math.min(...timestamps.map(t => t.getTime()))) : null;
    const newestMap = timestamps.length > 0 ? new Date(Math.max(...timestamps.map(t => t.getTime()))) : null;

    return {
      totalMaps,
      totalSize,
      averageSize,
      storageBackend: this.options.storageBackend,
      encryptionEnabled: this.options.encryptionEnabled,
      cacheHitRate,
      oldestMap,
      newestMap,
    };
  }

  /**
   * Clear expired cache entries
   */
  clearExpiredCache(): void {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (value.expires <= now) {
        this.cache.delete(key);
      }
    }
  }

  // ========== Helper Methods ==========

  private generateStorageKey(saliencyId: string, imageId: string): string {
    const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    return `${date}/${imageId}/${saliencyId}.${this.options.storageBackend === 'vault' ? 'enc' : 'png'}`;
  }

  private calculateChecksum(data: Buffer): string {
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  private async compressData(data: Buffer, quality: number): Promise<Buffer> {
    // In production, use a proper image compression library like sharp
    // For now, return data as-is
    return data;
  }

  private async decompressData(data: Buffer): Promise<Buffer> {
    // In production, use a proper image decompression library
    // For now, return data as-is
    return data;
  }

  private async encryptData(data: Buffer): Promise<Buffer> {
    if (!this.secureVault) {
      throw new Error('SecureVault not initialized');
    }

    // Generate and wrap DEK
    const { dek, wrappedKey } = await this.secureVault.generateAndWrapDEK();
    
    // Encrypt data with DEK
    const { ciphertext, iv, tag } = this.secureVault.encryptWithDEK(dek, data);
    
    // Combine wrapped key, iv, tag, and ciphertext for storage
    const combined = Buffer.concat([
      Buffer.from(wrappedKey),
      Buffer.from(iv, 'base64'),
      Buffer.from(tag, 'base64'),
      Buffer.from(ciphertext, 'base64'),
    ]);
    
    return combined;
  }

  private async decryptData(data: Buffer): Promise<Buffer> {
    if (!this.secureVault) {
      throw new Error('SecureVault not initialized');
    }

    // Extract components from combined data
    const wrappedKeyLength = 44; // Base64 encoded 32 bytes
    const ivLength = 16; // Base64 encoded 12 bytes
    const tagLength = 24; // Base64 encoded 16 bytes
    
    const wrappedKey = data.subarray(0, wrappedKeyLength).toString();
    const iv = data.subarray(wrappedKeyLength, wrappedKeyLength + ivLength).toString();
    const tag = data.subarray(wrappedKeyLength + ivLength, wrappedKeyLength + ivLength + tagLength).toString();
    const ciphertext = data.subarray(wrappedKeyLength + ivLength + tagLength).toString();
    
    // Unwrap DEK
    const dek = await this.secureVault.unwrapDEK(wrappedKey);
    
    // Decrypt data
    return this.secureVault.decryptWithDEK(dek, ciphertext, iv, tag);
  }

  private async applyRetentionPolicy(): Promise<void> {
    const now = new Date();
    const metadata = Array.from(this.metadataStore.values());
    
    // Apply age-based retention
    const maxAgeDate = new Date(now.getTime() - (this.options.retentionPolicy.maxAge * 24 * 60 * 60 * 1000));
    const expiredByAge = metadata.filter(m => m.createdAt < maxAgeDate);
    
    // Apply count-based retention
    const sortedByAge = metadata.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());
    const excessByCount = sortedByAge.slice(0, Math.max(0, sortedByAge.length - this.options.retentionPolicy.maxCount));
    
    // Delete expired items
    const toDelete = [...expiredByAge, ...excessByCount];
    for (const item of toDelete) {
      await this.deleteSaliencyMap(item.id);
    }
  }
}

// ========== Export Singleton Instance ==========

let saliencyStorageInstance: SaliencyMapStorageService | null = null;

export function getSaliencyMapStorage(options?: Partial<SaliencyMapStorageOptions>): SaliencyMapStorageService {
  if (!saliencyStorageInstance) {
    saliencyStorageInstance = new SaliencyMapStorageService(options);
  }
  return saliencyStorageInstance;
}

export function resetSaliencyMapStorage(): void {
  saliencyStorageInstance = null;
}

// ========== Export Types and Utilities ==========

export type {
  SaliencyMapMetadata,
  SaliencyMapStorageOptions,
  SaliencyMapQuery,
  SaliencyMapStorageResult,
  StorageBackend,
};